LINE_COMMENT: /\/\/[^\n]*/

// Block comments (/* ... */)
BLOCK_COMMENT: /\/\*[\s\S]*?\*\//

DECIMAL_LITERAL: /[0-9]+/
HEXADECIMAL_LITERAL: /0[xX][0-9a-fA-F]+/
INTEGER_LITERAL: DECIMAL_LITERAL | HEXADECIMAL_LITERAL
STRING_LITERAL: /"([^"\\]|\\.)*"/

?start: (variables | rule | invariant_rule)+

// CVL types
cvl_type: evm_type
        | PRIMITIVE_CVL_TYPE
        | ID // to parse something like field

// Basic types
basic_type: primitive_basic_type array_specifier*
            | struct_field_access

struct_field_access: ID "." ID

primitive_basic_type: INT_TYPE | UINT_TYPE | "address" | BOOL_TYPE | "string" | BYTES_TYPE

array_specifier: "[" [INTEGER_LITERAL] "]"

// EVM types
evm_type: (basic_type | tuple_type) array_specifier*

tuple_type: "(" inner_tuple ")"

inner_tuple: evm_type ("," evm_type)*

// Tokens
PRIMITIVE_CVL_TYPE: "mathint" | "calldataarg" | "method"
INT_TYPE: /int[0-9]*/
UINT_TYPE: /uint[0-9]*/
BYTES_TYPE: /bytes[0-9]*/
BOOL_TYPE: "bool"
ID: /[a-zA-Z_][a-zA-Z0-9_]*/

mapping: "mapping" "(" map_from "=>" map_to ")"

map_from: primitive_basic_type | ID

map_to: mapping | primitive_basic_type | ID

?expr:  literal
        | QUANTIFIER cvl_type ID "." expr
        | "(" exprs ")"
        | expr logic_binop expr -> logic_bi_expr
        | expr binop expr -> bi_expr
        | unop expr -> unary_expr
        | expr "?" expr ":" expr
        | ID index?
        | special_var_attribute_call
        | contract_attribute_call
        | ID index? attribute
        | func_compare_expr
        | function_call

QUANTIFIER: "forall" | "exists"
function_call: (ID ".")? ID "(" exprs? ")"?
func_compare_expr: "funcCompare(" ID "," STRING_LITERAL ")"

special_var_attribute: SUM | LENGTH
SUM: "sum"
LENGTH: "length"
special_var_attribute_call: ID "." special_var_attribute

CONTRACT: "contract"
contract_attribute: BALANCE | ADDRESS
BALANCE: "balance"
ADDRESS: "address"
contract_attribute_call: CONTRACT "." contract_attribute

index: "[" expr "]" ("[" expr "]")*
attribute: "." expr ("." expr)*
exprs: expr ("," expr)*

literal : TRUE | FALSE | INTEGER_LITERAL | STRING_LITERAL
TRUE: "true"
FALSE: "false"

unop    : TILDE | BANG | MINUS
BANG: "!"
TILDE: "~"

binop: PLUS | MINUS | STAR | SLASH | PERCENT
     | GT | LT | EQEQ | BANGEQ | GTEQ | LTEQ

logic_binop: ANDAND | OROR
     | FAT_ARROW | XOR_ARROW 

PLUS: "+"
MINUS: "-"
STAR: "*"
SLASH: "/"
PERCENT: "%"
GT: ">"
LT: "<"
EQEQ: "=="
BANGEQ: "!="
GTEQ: ">="
LTEQ: "<="
ANDAND: "&&"
OROR: "||"
FAT_ARROW: "=>"
XOR_ARROW: "<=>"

compare_binop: GT | LT | EQEQ | BANGEQ | GTEQ | LTEQ

special_field: block_field
                 | msg_field
                 | tx_field

block_field: "block" "." ("number" | "timestamp")
msg_field: "msg" "." ("address" | "sender" | "value")
tx_field: "tx" "." "origin"

MAX_UINT_VAR:   
    | "max_uint" | "max_address"
    | "max_uint8" | "max_uint16" | "max_uint32" | "max_uint64" | "max_uint128" | "max_uint256"

block: statement+

event_call: ID "(" exprs? ")"

statement:  "require" expr ("," STRING_LITERAL)? ";"  -> require_statement
            | "assert" expr ("," STRING_LITERAL)? ";"   -> assert_statement
            | cvl_type ID ("=" expr)? ";"                 -> define_statement

            | lhs "=" expr ";"                          -> assignment_statement
            |"if" expr statement ("else" statement)?    -> ifelse_statement
            | "{" block "}"                             -> block_statement

            | function_call ";"                         -> funccall_statement

            | "assert_modify" modify_var ("if" expr)? ("," STRING_LITERAL)? ";" -> assert_modify_statement
            | "assert_revert" ("if" expr)? ("," STRING_LITERAL)? ";" -> assert_revert_statement
            | "assert_emit" event_call ";"              -> assert_emit_statement
            | "emits" event_call ";"                         -> emits_statement

modify_var: ID index? attribute

lhs : ID ("[" expr "]")? ("," lhs)?

params : cvl_type ID? param*
param: "," cvl_type (ID)?

variables: "variables" "{" (variable_spec)* "}"

variable_type: cvl_type | mapping

variable_spec: variable_type ID ";"

rule : ("rule")? ID ("(" params? ")")? "{" block "}"

invariant_rule: ("invariant") ID "{" block "}"

// Ignore whitespace
%import common.WS
%ignore WS
%ignore LINE_COMMENT
%ignore BLOCK_COMMENT