LINE_COMMENT: /\/\/[^\n]*/

// Block comments (/* ... */)
BLOCK_COMMENT: /\/\*[\s\S]*?\*\//

DECIMAL_LITERAL: /[0-9]+/
HEXADECIMAL_LITERAL: /0[xX][0-9a-fA-F]+/
INTEGER_LITERAL: DECIMAL_LITERAL | HEXADECIMAL_LITERAL
STRING_LITERAL: /"([^"\\]|\\.)*"/

?start: (methods | rule | invariant_rule)+

// CVL types
cvl_type: evm_type
        | PRIMITIVE_CVL_TYPE
        | ID // to parse something like field

// Basic types
basic_type: primitive_basic_type array_specifier*
            | struct_field_access

struct_field_access: ID "." ID

primitive_basic_type: INT_TYPE | UINT_TYPE | "address" | BOOL_TYPE | "string" | BYTES_TYPE

array_specifier: "[" [INTEGER_LITERAL] "]"

// EVM types
evm_type: (basic_type | tuple_type) array_specifier*

tuple_type: "(" inner_tuple ")"

inner_tuple: evm_type ("," evm_type)*

// Tokens
PRIMITIVE_CVL_TYPE: "mathint" | "calldataarg" | "storage" | "env" | "method"
INT_TYPE: /int[0-9]*/
UINT_TYPE: /uint[0-9]*/
BYTES_TYPE: /bytes[0-9]*/
BOOL_TYPE: "bool"
ID: /[a-zA-Z_][a-zA-Z0-9_]*/

?expr:  literal
        | unop expr -> unary_expr
        | expr binop expr
        | "(" exprs ")"
        | expr "?" expr ":" expr
        | QUANTIFIER cvl_type ID "." expr
        | expr "." ID
        | ID index?
        | special_var_attribute_call
        | function_call
        | expr "in" ID

QUANTIFIER: "forall" | "exists"
function_call: (ID ".")? ID ("@" CALL_MODIFIER)? "(" exprs? ")" ("at" ID)?
special_var_attribute: SUM
SUM: "sum"
special_var_attribute_call: ID "." special_var_attribute
CALL_MODIFIER: "norevert" | "withrevert" | "dontsummarize"
index: "[" expr "]" ("[" expr "]")*
exprs: expr ("," expr)*

literal : TRUE | FALSE | INTEGER_LITERAL | STRING_LITERAL
TRUE: "true"
FALSE: "false"

unop    : TILDE | BANG | MINUS
BANG: "!"
TILDE: "~"

binop: PLUS | MINUS | STAR | SLASH | PERCENT | CARET
     | GT | LT | EQEQ | BANGEQ | GTEQ | LTEQ
     | AMP | PIPE | LSHIFT | RSHIFT | ANDAND | OROR
     | FAT_ARROW | XOR_ARROW | XOR | RSHIFT3

PLUS: "+"
MINUS: "-"
STAR: "*"
SLASH: "/"
PERCENT: "%"
CARET: "^"
GT: ">"
LT: "<"
EQEQ: "=="
BANGEQ: "!="
GTEQ: ">="
LTEQ: "<="
AMP: "&"
PIPE: "|"
LSHIFT: "<<"
RSHIFT: ">>"
ANDAND: "&&"
OROR: "||"
FAT_ARROW: "=>"
XOR_ARROW: "<=>"
XOR: "xor"
RSHIFT3: ">>>"

compare_binop: GT | LT | EQEQ | BANGEQ | GTEQ | LTEQ

special_field: block_field
                 | msg_field
                 | tx_field
                 | "length"
                 | "selector" | "isPure" | "isView" | "numberOfArguments" | "isFallback"

block_field: "block" "." ("number" | "timestamp")
msg_field: "msg" "." ("address" | "sender" | "value")
tx_field: "tx" "." "origin"

SPECIAL_VARS:
           | "lastReverted"
           | "lastStorage"
           | "allContracts"
           | "lastMsgSig"
           | "_"
           | MAX_UINT_VAR
           | "nativeBalances"
           | "calledContract"
           | "executingContract"

MAX_UINT_VAR:   
    | "max_uint" | "max_address"
    | "max_uint8" | "max_uint16" | "max_uint32" | "max_uint64" | "max_uint128" | "max_uint256"

REQUIRE_FUNCTION : "require_uint8" | "require_uint16" | "require_uint32" | "require_uint64" | "require_uint128" | "require_uint256" 
    | "require_int8" | "require_int16" | "require_int32" | "require_int64" | "require_int128" | "require_int256"

TO_FUNCTION : "to_mathint" | "to_bytes1" | "to_bytes2" | "to_bytes8" | "to_bytes4" | "to_bytes16" | "to_bytes32"

ASSERT_FUNCTION : "assert_uint8" | "assert_uint16" | "assert_uint32" | "assert_uint64" | "assert_uint128" | "assert_uint256" 
    | "assert_int8" | "assert_int16" | "assert_int32" | "assert_int64" | "assert_int128" | "assert_int256" | "assert_address"

cast_functions : REQUIRE_FUNCTION | ASSERT_FUNCTION | TO_FUNCTION

contract : ID | "currentContract"

block: statement+

statement:  cvl_type ID ("=" expr)? ";"                 -> define_statement
            | "require" expr ("," STRING_LITERAL)? ";"  -> require_statement
            | "assert" expr ("," STRING_LITERAL)? ";"   -> assert_statement
            | "satisfy" expr ("," STRING_LITERAL)? ";"  -> satisfy_statement

            | "requireInvariant" ID "(" exprs ")" ";"   -> requireinv_statement

            | lhs "=" expr ";"                          -> assignment_statement
            |"if" expr statement ("else" statement)?    -> ifelse_statement
            | "{" block "}"                             -> block_statement
            | "return" (expr)? ";"                      -> return_statement

            | function_call ";"                         -> funccall_statement
            | "reset_storage" expr ";"                  -> reset_statement

            | "havoc" ID ("assuming" expr)? ";"         -> havoc_statement

lhs : ID ("[" expr "]")? ("," lhs)?

import : "import" STRING_LITERAL
use: "use" "rule" ID ("filtered" "{" ID "->" expr ("," ID "->" expr)*)?
    | "use" "builtin" "rule" ID
    | "use" "invariant" ID ("filtered" "{" ID "->" expr "}")? ("{" (preserved_block)* "}" )?

using : "using" ID "as" ID

preserved_block: "preserved" (method_signature)? ("with(" params ")")? block
method_signature:   (contract_name ".")? ID "(" (cvl_type ID? method_param*)? ")" 
                    | "fallback" "(" ")"
method_param : "," cvl_type (ID)?
contract_name : ID | "_"
params : cvl_type data_location? ID? param*
param: "," cvl_type data_location? (ID)?

data_location : "memory" | "calldata" | "storage"

methods : "methods" "{" (method_spec)* "}"

method_spec : "function" (exact_pattern | wildcard_pattern | catch_all_pattern | catch_unresolved_calls_pattern) ("returns" "(" cvl_type ")")? ("envfree" | "with" "(" "env" ID ")")? ("optional")? ("=>" method_summary ("UNRESOLVED" | "ALL" | "DELETE")?)? ";"

exact_pattern : (ID ".")? ID "(" params? ")" VISIBILITY ("returns" "(" cvl_type ")")?
wildcard_pattern : "_" "." ID "(" params? ")" VISIBILITY
catch_all_pattern : ID "." "_" "external"
catch_unresolved_calls_pattern : "_" "." "_" "external"

VISIBILITY : "internal" | "external"
method_summary : "ALWAYS" "(" INTEGER_LITERAL ")"
                | "CONSTANT"
                | "PER_CALLEE_CONSTANT"
                | "NONDET"
                | "HAVOC_ECF"
                | "HAVOC_ALL"
                | "DISPATCHER" ("(" ( "true" | "false" ) ")")?
                | "AUTO"
                | "ASSERT_FALSE"
                | expr ("expect" ID)?
                | "DISPATCH" ("(optimistic=false)")?  "[" (dispatch_list_patterns)? "]" "default" method_summary
                | "DISPATCH" ("(optimistic=true)")?  "[" (dispatch_list_patterns)? "]"

dispatch_list_patterns :  dispatch_list_patterns "," dispatch_pattern
                    | dispatch_pattern

dispatch_param : cvl_type (ID)?

dispatch_pattern : "_" "." ID "(" dispatch_param ")"
                     | ID "." "_"
                     | ID "." ID "(" dispatch_param ")"

rule : ("rule")? ID ("(" params? ")")? ("filtered" "{" ID "->" expr ("," ID "->" expr)* "}")? ("description" STRING_LITERAL)? ("good_description" STRING_LITERAL)? block

invariant_rule: ("invariant") ID block

// Ignore whitespace
%import common.WS
%ignore WS
%ignore LINE_COMMENT
%ignore BLOCK_COMMENT